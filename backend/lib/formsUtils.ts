import { Database } from "./supabaseTypes";
import {
  MultiRecordCreateFormSchema,
  SingleRecordCreateFormSchema,
  SingleRecordEditFormSchema,
} from "../../shared/schema/schema";
import type { Form as FormSchemaType } from "../../shared/schema/schema"; // Use this for inputs (e.g. the request made from the frontend)
import type {
  Base,
  BaseForm,
  // TODO: This will be necessary later, pls fix
  Form,
  FormField,
  SingleRecordCreateForm,
  SingleRecordEditForm,
  Table,
} from "../../shared/types/formTypes"; // Use this for responses
import { supabase } from "./supabase";
import { PostgrestError } from "@supabase/supabase-js";
import { FilterCondition } from "@shared/types/filterConditionTypes";

// # SHORTHAND TYPES

// Aliases for the autogenerated types in our database.
export type BaseFormRow = Database["public"]["Tables"]["base_form"]["Row"];
export type SingleRecordEditFormRow =
  Database["public"]["Tables"]["single_record_edit_form"]["Row"];
export type FormsViewRow = Database["public"]["Views"]["forms"]["Row"];

// # FORM VALIDATION

/**
 * Given an object, it validates whether or not it is a proper form config
 * @param formConfig A potential
 * @returns Nothing
 */
export function validateFormConfigInput(formConfig: FormSchemaType): void {
  // When validating, we omit certain things we don't expect users to pass
  // (id, updatedAt)
  if (formConfig.type === "singleRecordCreate") {
    SingleRecordCreateFormSchema.parse(formConfig);
    return;
  } else if (formConfig.type === "singleRecordEdit") {
    SingleRecordEditFormSchema.parse(formConfig);
    return;
  } else if (formConfig.type === "multiRecordCreate") {
    MultiRecordCreateFormSchema.parse(formConfig);
    return;
  }

  // If the form config type isn't recognized OR isn't a form config at all
  throw new Error("Invalid form config");
}

// # TRANSFORM RECORDS TO FORM
// Everything in this section transform a record from our Supabase to either BaseForm/Form objects

/**
 * This is meant for retrieving one or more records from our `base_form` table. It translates the
 * Supabase record into a `BaseForm` type.
 * @param baseFormRecord A record from the `base_form` table in our Supabase project
 * @returns A `BaseForm` object
 */
export const transformBaseFormRecordToForm = (
  baseFormRecord: BaseFormRow,
): BaseForm => {
  return {
    id: baseFormRecord.id,
    type: baseFormRecord.type,
    name: baseFormRecord.name,
    description: baseFormRecord.description as string,
    base: JSON.parse(baseFormRecord.base as string) as Base,
    targetTable: JSON.parse(baseFormRecord.target_table as string) as Table,
    selectedFields: JSON.parse(
      baseFormRecord.selected_fields as string,
    ) as FormField[],
    createdAt: baseFormRecord.created_at,
    updatedAt: baseFormRecord.updated_at,
  } satisfies BaseForm;
};

// ## TYPE SPECIFIC TRANSFORMS
// Everything in this section deals with type specific transformations, they have to be updated
// every time we add a new form type

/**
 * This is meant for instances where you have a record from the `base_form` table and its corresponding
 * type specific record from one of the children tables (ex. `single_record_edit_form`). Given both
 * records, it translates them to a `Form` object.
 * @param baseFormRecord A record from the `base_form` table in our Supabase project
 * @param typeSpecificFormRecord A record from one of the type specific form tables in our Supabase project
 * @returns A `Form` object with both base form and type specific form attributes
 */
export const transformRecordToForm = (
  baseFormRecord: BaseFormRow,
  // In the future, this type will be a union
  typeSpecificFormRecord:
    | SingleRecordEditFormRow
    // eslint-disable-next-line @typescript-eslint/no-empty-object-type
    | {}, // Empty object if no type specific data (single record create forms are no different than base forms)
): Form => {
  const baseForm = transformBaseFormRecordToForm(baseFormRecord);

  if (baseFormRecord.type === "singleRecordEdit") {
    return {
      ...baseForm,
      type: "singleRecordEdit",
      formFilters: JSON.parse(
        // If the baseForm.type is singleRecordEdit, we know what type of form info we're getting
        (typeSpecificFormRecord as SingleRecordEditFormRow)
          .form_filters as string,
      ) as FilterCondition[],
    } satisfies SingleRecordEditForm;
  }

  // If none of the types match, it must be singleRecordCreate form
  return {
    ...baseForm,
    type: "singleRecordCreate",
  } satisfies SingleRecordCreateForm;
};

/**
 * This is meant for retrieving one or more records from our "forms" view. It translates the Supabase
 * record into a Form type.
 * @param record A record from the "forms" view in our Supabase project
 * @returns A Form object (with type specific attributes)
 */
export const transformFormsViewRecordToForm = (record: FormsViewRow): Form => {
  const baseForm = {
    id: record.id as string,
    type: record.type as Database["public"]["Enums"]["form_type"],
    name: record.name as string,
    description: record.description ? record.description : undefined,
    base: JSON.parse(record.base as string) as Base,
    targetTable: JSON.parse(record.target_table as string) as Table,
    selectedFields: JSON.parse(record.selected_fields as string) as FormField[],
    createdAt: record.created_at as string,
    updatedAt: record.updated_at as string,
  } satisfies BaseForm;

  if (record.type === "singleRecordEdit") {
    // If the baseForm.type is singleRecordEdit, we know what type of form info we're getting
    return {
      ...baseForm,
      type: "singleRecordEdit",
      formFilters: record.form_filters
        ? (JSON.parse(record.form_filters as string) as FilterCondition[])
        : [],
    } satisfies SingleRecordEditForm;
  }

  // If none of the types match, it must be singleRecordCreate form
  return {
    ...baseForm,
    type: "singleRecordCreate",
  } satisfies SingleRecordCreateForm;
};

// # TYPE SPECIFIC SUPABASE QUERIES
// Everything in this section deals with how we query our Supabase's type specific form tables
// (POST, PUT, etc.). These functions have to be udpated every time we add a new form type

/**
 * This function assumes you've already posted the relevant data to `base_form` table in our
 * Supabase project. Given that record and a form config object, post the type specific data to the
 * proper table.
 * @param formConfig A validated `FormSchemaType` form config
 * @param baseFormData A record from the `base_form` table in our Supabase project
 * @returns `{data, error}` where `data` is a record from the type specific form tables (or `null`) and `error` is a `PostgrestError | null`
 */
export const postTypeSpecificForm = async (
  formConfig: FormSchemaType,
  baseFormData: Database["public"]["Tables"]["base_form"]["Row"],
) => {
  if (formConfig.type === "singleRecordCreate") {
    return { data: {}, error: null };
  } else if (formConfig.type === "singleRecordEdit") {
    console.log("singleRecordEdit - Publish");
    const newSingleRecordEditForm: Database["public"]["Tables"]["single_record_edit_form"]["Insert"] =
      {
        id: baseFormData.id,
        form_filters: JSON.stringify(formConfig.formFilters),
      };

    const {
      data,
      error,
    }: {
      data: SingleRecordEditFormRow | null;
      error: PostgrestError | null;
    } = await supabase
      .from("single_record_edit_form")
      .insert(newSingleRecordEditForm)
      .select()
      .single();

    return { data, error };
  }

  console.log("postTypeSpecificForm: Invalid form type");
  return { data: null, error: null };
};

/**
 * This function already assumes you've already updated the relevant data in the `base_form` table
 * in our Supabase project. Given that record and a form config object, update the type specific data
 * in the proper table.
 * @param formConfig A validated `FormSchemaType` form config
 * @param formId The ID of the form to be updated
 * @returns
 */
export const putTypeSpecificForm = async (
  formConfig: FormSchemaType,
  formId: string,
) => {
  if (formConfig.type === "singleRecordCreate") {
    return { data: {}, error: null };
  } else if (formConfig.type === "singleRecordEdit") {
    const updatedSingleRecordEditForm: Database["public"]["Tables"]["single_record_edit_form"]["Update"] =
      {
        form_filters: JSON.stringify(formConfig.formFilters),
      };

    const {
      data,
      error,
    }: {
      data: SingleRecordEditFormRow | null;
      error: PostgrestError | null;
    } = await supabase
      .from("single_record_edit_form")
      .update(updatedSingleRecordEditForm)
      .eq("id", formId)
      .select()
      .single();

    return { data, error };
  }

  console.log("putTypeSpecificForm: Invalid form type");
  return { data: null, error: null };
};
