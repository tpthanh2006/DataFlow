import { z } from "zod";
import {
  AIRTABLE_AUTOGEN_FIELD_TYPES,
  AIRTABLE_FIELD_TYPES,
} from "../types/airtableFieldType";

// All the valid field types from Airtable
export const AirtableFieldTypeSchema = z.enum(AIRTABLE_FIELD_TYPES);

export const AirtableFieldSchema = z.object({
  id: z.string().min(1, "Airtable Field ID is required"),
  name: z.string().min(1, "Airtable field name is required"),
  type: AirtableFieldTypeSchema,
  description: z.string().optional(),
  options: z.record(z.string(), z.any()).optional(),
});
export type AirtableField = z.infer<typeof AirtableFieldSchema>;

// TODO: May need to edit the error messages to be more specific/indicate which field is bad specifically
export const FormFieldSchema = z
  .object({
    original: AirtableFieldSchema,
    isRequired: z.boolean(),
    isEditable: z.boolean(),
    defaultValue: z.unknown().optional(),
    placeholder: z.string().optional(),
  })
  .refine(
    (data) =>
      !(data.original.type in AIRTABLE_AUTOGEN_FIELD_TYPES) ||
      !(data.isRequired || data.isEditable),
    {
      message:
        "Autogenerated/unknown field types cannot be editable or required",
    },
  )
  .refine((data) => !data.isRequired || data.isEditable, {
    message: "Required fields must be editable",
    path: ["isRequired"],
  });
export type FormField = z.infer<typeof FormFieldSchema>;

export const TableSchema = z.object({
  id: z.string().min(1, "Table ID is required"),
  name: z.string().min(1, "Table name is required"),
  primaryFieldId: z.string().min(1, "Primary field ID is required"),
  description: z.string().optional(),
  fields: z.array(AirtableFieldSchema),
});
export type Table = z.infer<typeof TableSchema>;

export const BaseSchema = z.object({
  id: z.string().min(1, "Base ID is required"),
  name: z.string().min(1, "Base name is required"),
  tables: z.array(TableSchema).optional(),
});
export type Base = z.infer<typeof BaseSchema>;

export const FilterConditionSchema = z.object({
  field: AirtableFieldSchema,
  operation: z.string(),
  value: z.unknown().optional(),
  logicalOperator: z.enum(["and", "or"]).optional(),
});
export type FilterCondition = z.infer<typeof FilterConditionSchema>;

const FormTypeEnum = z.enum([
  "singleRecordCreate",
  "singleRecordEdit",
  "multiRecordCreate",
]);

export const BaseFormSchema = z.object({
  name: z.string().min(1, "Form name is required"),
  description: z.string().optional(),
  base: BaseSchema,
  targetTable: TableSchema,
  selectedFields: z
    .array(FormFieldSchema)
    .min(1, "At least 1 field must be selected"),

  // These attributes aren't needed for input aside from creating a proper Form type.
  // The server/database will create these automatically, so we never need to check these
  // when validating user inputs on the frontend or HTTP requests on the backend
  // If you need these attributes when typing, it's better to use shared/types/formTypes instead

  // id: z.string().min(1, "Form ID is required"),
  // createdAt: z.union([z.date(), z.string()]), // Either a Date object or an ISO Date string
  // updatedAt: z.union([z.date(), z.string()]),
});
export type BaseForm = z.infer<typeof BaseFormSchema>;

export const SingleRecordCreateFormSchema = z.object({
  ...BaseFormSchema.shape,
  type: z.literal(FormTypeEnum.enum.singleRecordCreate),
});
export type SingleRecordCreateForm = z.infer<
  typeof SingleRecordCreateFormSchema
>;

// TODO: Add additional logic to this :)
export const SingleRecordEditFormSchema = z.object({
  ...BaseFormSchema.shape,
  type: z.literal(FormTypeEnum.enum.singleRecordEdit),
  formFilters: z.array(FilterConditionSchema),
});
export type SingleRecordEditForm = z.infer<typeof SingleRecordEditFormSchema>;

// TODO: Basically all the below stuff needs to be reworked depending on how we design
// multirecord creation forms/dynamic forms

export const FieldMappingSchema = z.object({
  linkedRecordField: FormFieldSchema, // FormField schema because users will interact with this in the survey
  referenceField: AirtableFieldSchema,
});

export const TriggerFieldSchema = z
  .object({
    field: FormFieldSchema,
    referenceField: AirtableFieldSchema,
    filterCondition: FilterConditionSchema,
  })
  .refine((data) => data.referenceField.id === data.filterCondition.field.id, {
    message:
      "The trigger field's filter condition can only be applied to the reference field",
  });

export const MultiRecordCreateFormSchema = z.object({
  ...BaseFormSchema.shape, // Extends the base form/single record create form
  type: z.literal(FormTypeEnum.enum.multiRecordCreate),
  referenceTable: TableSchema,
  fieldMapping: FieldMappingSchema,
  sharedFields: z.array(FormFieldSchema).optional(),
  preFilterCondition: FilterConditionSchema.optional(),
  triggerField: TriggerFieldSchema,
});
export type MultiRecordCreateForm = z.infer<typeof MultiRecordCreateFormSchema>;

export type Form =
  | SingleRecordCreateForm
  | SingleRecordEditForm
  | MultiRecordCreateForm;
