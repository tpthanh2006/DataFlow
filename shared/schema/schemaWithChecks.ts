import { z } from "zod";
import {
  AIRTABLE_AUTOGEN_FIELD_TYPES,
  AIRTABLE_FIELD_TYPES,
} from "../types/airtableFieldType";
import {
  MultiRecordCreateFormSchema,
  SingleRecordCreateFormSchema,
} from "./schema";

/**
 * TODO: This needs some additional validation checks :
 * - Base is one that exists in the workspace (this will likely require an Airtable API call)
 *
 * Note: any refines we add here may need to be added to DynamicFormCreation :/
 */
export const SingleRecordCreateFormSchemaWithChecks = z
  .object({
    ...SingleRecordCreateFormSchema.shape,
  })
  .refine(
    (data) =>
      data.base.tables &&
      data.base.tables.some((table) => table.id === data.targetTable.id),
    {
      // TODO: This may be bad logic-- bases retrieved from the API don't come with tables-- those
      // come from another call
      message: "Target table does not exist in the selected base.",
      path: ["targetTable"],
    },
  )
  .refine(
    (data) =>
      // Check that every selected field belongs to targetTable
      data.selectedFields.every((selectedField) =>
        data.targetTable.fields.some(
          (tableField) => tableField.id === selectedField.original.id,
        ),
      ),
    {
      // It would better if this said which field was erroneous but I don't think zod can :/
      message: "All selected fields must exist in the target table",
      path: ["selectedFields"],
    },
  )
  .refine(
    (data) =>
      // Check that every selectedField is of a known type and is not an autogenerated type
      data.selectedFields.every(
        (field) =>
          AIRTABLE_FIELD_TYPES.includes(field.original.type) &&
          !AIRTABLE_AUTOGEN_FIELD_TYPES.includes(field.original.type),
      ),
    {
      message:
        "All selected fields must be of a known, non-autogenerated field type",
      path: ["selectedFields"],
    },
  );

/**
 * Anytime we add a refine to StaticFormCreationSchemaWithChecks, we also need to add it these :(
 *
 */
export const MultiRecordCreateFormSchemaWithChecks = z
  .object({
    ...MultiRecordCreateFormSchema.shape,
  })
  .refine(
    (data) =>
      data.base.tables &&
      data.base.tables.some((table) => table.id === data.targetTable.id),
    {
      // TODO: This may be bad logic-- bases retrieved from the API don't come with tables-- those
      // come from another call
      message: "Target table does not exist in the selected base.",
      path: ["targetTable"],
    },
  )
  .refine(
    (data) =>
      // Check that every selected field belongs to targetTable
      data.selectedFields.every((selectedField) =>
        data.targetTable.fields.some(
          (tableField) => tableField.id === selectedField.original.id,
        ),
      ),
    {
      // It would better if this said which field was erroneous but I don't think zod can :/
      message: "All selected fields must exist in the target table",
      path: ["selectedFields"],
    },
  )
  .refine(
    (data) =>
      // Check that every selectedField is of a known type and is not an autogenerated type
      data.selectedFields.every(
        (field) =>
          AIRTABLE_FIELD_TYPES.includes(field.original.type) &&
          !AIRTABLE_AUTOGEN_FIELD_TYPES.includes(field.original.type),
      ),
    {
      message:
        "All selected fields must be of a known, non-autogenerated field type",
      path: ["selectedFields"],
    },
  )
  // Everything above this comment is stuff "inherited" from the Single Record Creation Forms/Base Form
  // Everything below this comment is stuff specifically for Multi Record Creation Forms
  .refine(
    (data) =>
      data.base.tables &&
      data.base.tables.some((table) => table.id === data.referenceTable.id),
    {
      // TODO: This may be bad logic-- bases retrieved from the API don't come with tables-- those
      // come from another call
      message: "Reference table does not exist in the selected base.",
      path: ["referenceTable"],
    },
  )
  .refine((data) => data.referenceTable.id !== data.targetTable.id, {
    message: "Reference table cannot be the same as the target table",
    path: ["referenceTable"],
  })
  .refine((data) =>
    data.targetTable.fields.some(
      (field) => data.fieldMapping.linkedRecordField.original.id === field.id,
      {
        message: "Linked record field does not exist in the target table",
        path: ["fieldMapping"],
      },
    ),
  )
  .refine((data) =>
    data.referenceTable.fields.some(
      (field) => data.fieldMapping.linkedRecordField.original.id === field.id,
      {
        message: "Reference field does not exist in the reference table",
        path: ["fieldMapping"],
      },
    ),
  )
  .refine(
    (data) =>
      data.sharedFields?.every(
        (field) =>
          field.original.id != data.fieldMapping.linkedRecordField.original.id,
      ),
    {
      message: "None of the shared fields can be the linked record field",
      path: ["sharedFields"],
    },
  )
  .refine(
    (data) =>
      data.referenceTable.fields.some(
        (field) => field.id === data.triggerField.referenceField.id,
      ),
    {
      message: "Reference field does not exist in the reference table",
      path: ["triggerField"],
    },
  )
  .refine(
    (data) =>
      data.targetTable.fields.some(
        (field) => field.id === data.triggerField.field.original.id,
      ),
    {
      message: "Trigger field does not exist the target table",
      path: ["triggerField"],
    },
  )
  .refine(
    (data) =>
      data.triggerField.field.original.id !==
      data.fieldMapping.linkedRecordField.original.id,
    {
      message:
        "Trigger field cannot be the linked record field using in field mapping",
      path: ["triggerField"],
    },
  );
